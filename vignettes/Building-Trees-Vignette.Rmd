---
title: 'Build B cell lineage trees'
author: "Kenneth B. Hoehn"
date: '`r Sys.Date()`'
output:
  pdf_document:
    dev: pdf
    fig_height: 4
    fig_width: 7.5
    highlight: pygments
    toc: yes
  html_document:
    fig_height: 4
    fig_width: 7.5
    highlight: pygments
    theme: readable
    toc: yes
  md_document:
    fig_height: 4
    fig_width: 7.5
    preserve_yaml: no
    toc: yes
geometry: margin=1in
fontsize: 11pt
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Build Lineage Trees}
  %\VignetteEncoding{UTF-8}  
  %\usepackage[utf8]{inputenc}
---

Dowser offers multiple ways to build B cell phylogenetic trees. These differ by the method used to estimate tree topology and branch lengths (e.g. maximum parsimony and maximum likelihood) and implementation (IgPhyML, PHYLIP, or R packages ape and phangorn).

Before trees can be built, B cell sequences must be separated into clonal clusters, and had their clonal germline sequences reconstructed. Default settings assume input data is in AIRR TSV format, though column names may be specified using function arguments.

## Format clones

Before trees can be built, data must be formatted into a data table of AIRR clone objects. This is accomplished using the formatClones function. This function will:

1. Change non-nucleotide characters to `N` characters.
2. By default, collapse sequences that are either identical or differ only by ambiguous characters. 
3. Sequences will not be collapsed if they differ by columns specified in the `traits` option, or if the `collapse` option is set to `FALSE`.
4. Include data columns specified by `num_fields` or `text_fields`.
5. Remove uninformative sequence sites in which all sequences have `N` characters.

The output of this function is a tibble in which each row is a clone, ordered by the number of sequences. The column `data` contains airrClone objects with the clonal sequence alignments. Other columns contain information about the clone, and can be specified using the `columns` argument.

```{r, eval=TRUE, warning=FALSE, message=FALSE}
library(dowser)

# load example AIRR tsv data
data(ExampleAirr)

# Subset data for this example
ExampleAirr = ExampleAirr[ExampleAirr$clone_id %in% c("3170", "3184"),]
ExampleAirr$subject_id = "Subject_1"

# Process example data using default settings
clones = formatClones(ExampleAirr)

print(clones)

# Process example data keeping samples from different times
# distinct, adding duplicate_count among collapsed sequences,
# and show the sample_id within each clone in the tibble.
clones = formatClones(ExampleAirr, traits=c("sample_id","c_call"),
    num_fields=c("duplicate_count"), columns=c("subject_id"))

print(clones)
```

## Build maximum parsimony trees

A common way to build B cell lineage trees is the find the tree topology that minimizes the number of mutations needed along the tree (i.e. is the most parsimonious). Branch lengths can then be estimated as the number of mutations per site between each node in the tree.

Maximum parsimony trees can be built with the `getTrees` function, which by default uses the `pratchet` maximum parsimony function in the `phangorn` phylogenetics package.

The output is the same tibble as the input, but with a `trees` column containing an R `ape::phylo` object for each clone.

Build trees using *phangorn's pratchet*. 
```{r, eval=FALSE, warning=FALSE, message=FALSE}

clones = getTrees(clones, nproc=1)

print(clones)
## A tibble: 2 x 6
#  clone_id data       locus  seqs subject_id trees  
#     <dbl> <list>     <chr> <int> <chr>      <list> 
#1     3170 <airrClon> N        13 Subject_1  <phylo>
#2     3184 <airrClon> N        12 Subject_1  <phylo>
```

Maximum parsimony trees can also be built using the PHYLIP function `dnapars`. To do this, the `build` option needs to be set as `dnapars` and the path to the `dnapars` executable needs to be specified in the `exec` option.

[PHYLIP download site](https://evolution.genetics.washington.edu/phylip/getme-new1.html)

Build trees using *dnapars*. 
```{r, eval=FALSE, warning=FALSE, message=FALSE}
# exec here is set to dnapars position in the Docker image.
clones = getTrees(clones, build="dnapars", exec="/usr/local/bin/dnapars", nproc=1)

clones
## A tibble: 2 x 6
#  clone_id data       locus  seqs subject_id trees  
#     <dbl> <list>     <chr> <int> <chr>      <list> 
#1     3170 <airrClon> N        13 Subject_1  <phylo>
#2     3184 <airrClon> N        12 Subject_1  <phylo>
```

## Build maximum likelihood trees

A common way to build B cell lineage trees is the find the tree topology and branch lengths that maximize the likelihood of the sequence data given a substitution model.

Standard maximum likelihood trees can also be built with the `getTrees` function, which if specified the `optim.pml` function in the `phangorn` phylogenetics package.

Maximum likelihood trees can also be built using the PHYLIP function `dnaml`. To do this, the `build` option needs to be set as `dnaml` and the path to the `dnaml` executable needs to be specified in the `exec` option. 

Another maximum likelihood option that dowser supports is `raxml` which utilizes RAxML Next Generation. This option also needs a path to the `raxml` executable specified in the `exec` option. 

Build trees using *phangorn's optim.pml*.
```{r, eval=FALSE, warning=FALSE, message=FALSE}

clones = getTrees(clones, build="pml")

print(clones)
## A tibble: 2 x 6
#  clone_id data       locus  seqs subject_id trees  
#     <dbl> <list>     <chr> <int> <chr>      <list> 
#1     3170 <airrClon> N        13 Subject_1  <phylo>
#2     3184 <airrClon> N        12 Subject_1  <phylo>
```
Build trees using *dnaml* instead, which like `dnapars` is also distributed as part of `PHYLIP`.

```{r, eval=FALSE, warning=FALSE, message=FALSE}

# exec here is set to dnaml position in the Docker image.
clones = getTrees(clones, build="dnaml", exec="/usr/local/bin/dnaml")

clones
# A tibble: 2 x 6
#  clone_id data       locus  seqs subject_id trees  
#     <dbl> <list>     <chr> <int> <chr>      <list> 
#1     3170 <airrClon> N        13 Subject_1  <phylo>
#2     3184 <airrClon> N        12 Subject_1  <phylo>
```
Build trees using *RAxML*.

[RAxML documentation/download site](https://github.com/amkozlov/raxml-ng)

```{r, eval=FALSE, warning=FALSE, message=FALSE}

# exec here is set to raxml position in the Docker image.
clones = getTrees(clones, build="raxml", exec="/usr/local/share/raxml-ng")

clones
# A tibble: 2 x 6
#  clone_id data       locus  seqs subject_id trees  
#     <dbl> <list>     <chr> <int> <chr>      <list> 
#1     3170 <airrClon> N        13 Subject_1  <phylo>
#2     3184 <airrClon> N        12 Subject_1  <phylo>
```
## Build IgPhyML B cell trees

B cell somatic hypermutation violates important assumptions in most phylogenetic models. IgPhyML implements models that incorporate SHM hotspot and coldspot motifs. To build trees using IgPhyML, specify the build option appropriately and pass the location of the IgPhyML executable. The returns object will also include a `parameters` column, which will contain the HLP19 model parameters estimated from IgPhyML.

Note: This function is slower than other maximum likelihood and parsimony approaches.

[IgPhyML documentation/download site](https://igphyml.readthedocs.io)

```{r, eval=FALSE, warning=FALSE, message=FALSE}

# exec here is set to IgPhyML position in the Docker image.
clones = getTrees(clones, build="igphyml", 
    exec="/usr/local/share/igphyml/src/igphyml", nproc=1)

print(clones)
## A tibble: 2 x 7
#  clone_id data       locus  seqs subject_id trees        parameters       
#     <dbl> <list>     <chr> <int> <chr>      <named list> <named list>     
#1     3170 <airrClon> N        13 Subject_1  <phylo>      <named list [13]>
#2     3184 <airrClon> N        12 Subject_1  <phylo>      <named list [13]>


clones$parameters[[1]]$omega_mle
#[1] 0.5286
```
## Building maximum likelihood trees with multiple partitions

Single cell data can now provide data that has paired heavy and light chain BCR data. Two of the tree building methods that dowser supports, IgPhyMl and RAxML, support multiple partition options. In both of these methods, a "scaled" model approach is used. This approach allows heavy and light chain branch lengths to differ by a scalar factor estimated by maximum likelihood. 

IgPhyML current supports six different kinds of partitions. 
1. `single`
- This is how IgPhyML normally runs. This will not start multiple partitions and only use one omega. 
2. `cf`
- This will use two different omegas. One for all CDRs and one for all FWRs
3. `hl`
- This will use two different omegas. One for the heavy and one for the light chain. 
4. `hlf`
- This will use three different omegas. One for all CDRs, one for the heavy FWR, and one for the light FWR
5. `hlc`
- This will use three different omegas. One for all FWRs, one for the heavy CDR, and one for the light CDR
6. `hlcf`
- This will use four different omegas. One for each heavy/light CDR/FWR combination


In addition to the partition variable, IgPhyML will also need an `omega` and `rates` parameter. The `omegas` parameter is a vector of 'e' equal to the number of omegas required for the partition. `rates` is a parameter that shows which omegas should be associated with a given rate. The rate parameter lists the heavy rates first, then the light chain rates. It also lists the FWR rates before the CDR rates. 

For example, if you wanted different rates heavy and light chains with two omegas, the `omegas` parameter would be "e,e" and the `rates` parameter would be  "0,1". 

But if you wanted four different omegas, but the wanted the light chain CDR and FWR to have the same rate and the heavy chain CDR and FWR to have a different rate the code would be `omegas`= "e,e,e,e", `rates`="0,0,1,1".

However, if you wanted the CDRs to have the same rate and the FWRs to have a different rate the code would be `omegas`= "e,e,e,e", `rates`="0,1,0,1".

Building maximum likelihood trees with multiple partitions using *IgPhyML*. 
```{r, eval=FALSE, warning=FALSE, message=FALSE}

# exec here is set to IgPhyML position in the Docker image.
clones = getTrees(clones, build="igphyml", 
    exec="/usr/local/share/igphyml/src/igphyml", nproc=1, id="hl", omega="e,e", rates="0,1")

print(clones)
## A tibble: 2 x 7
#  clone_id data       locus  seqs subject_id trees        parameters       
#     <dbl> <list>     <chr> <int> <chr>      <named list> <named list>     
#1     3170 <airrClon> N        13 Subject_1  <phylo>      <named list [13]>
#2     3184 <airrClon> N        12 Subject_1  <phylo>      <named list [13]>
```

Building maximum likelihood trees with multiple partitions using *RAxML* instead
```{r, eval=FALSE, warning=FALSE, message=FALSE}

# exec here is set to RAxML position in the Docker image.
clones = getTrees(clones, build="raxml", 
    exec="/usr/local/share/raxml-ng", nproc=1, partition=TRUE)

print(clones)
## A tibble: 2 x 7
#  clone_id data       locus  seqs subject_id trees        parameters       
#     <dbl> <list>     <chr> <int> <chr>      <named list> <named list>     
#1     3170 <airrClon> N        13 Subject_1  <phylo>      <named list [13]>
#2     3184 <airrClon> N        12 Subject_1  <phylo>      <named list [13]>i
```