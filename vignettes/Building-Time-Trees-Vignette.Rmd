---
title: "Build Time Trees Using TyCHE and BEAST"
author: "Jessie Fielding"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_height: 4
    fig_width: 7.5
    highlight: pygments
    theme: readable
    toc: yes
  pdf_document:
    dev: pdf
    fig_height: 4
    fig_width: 7.5
    highlight: pygments
    toc: yes
  md_document:
    fig_height: 4
    fig_width: 7.5
    preserve_yaml: no
    toc: yes
geometry: margin=1in
fontsize: 11pt
vignette: >
  %\VignetteIndexEntry{Build Time Trees Using TyCHE and BEAST}
  %\VignetteEncoding{UTF-8}  
  %\usepackage[utf8]{inputenc}
  %\VignetteEngine{knitr::rmarkdown}
---

## Building Time Trees

There are many options for building time trees using BEAST2. Here we demonstrate
how to use TyCHE to fit a trait-linked clock for heterogeneous evolution to
B-cell data. 

Inferring time-resolved phylogenies requires a clock model, which describes the 
relationship between evolution and time within the population. A “strict clock” 
model assumes a constant rate of evolution over time. Other models allow clock 
rates to vary, such as the uncorrelated lognormal distribution relaxed clock.

Inferring time trees for cell populations using natural mutations is challenging 
because cellular evolution is highly heterogenous. For example, B cells undergo 
periods of rapid somatic hypermutation in germinal centers during immune 
responses before becoming quiescent memory cells.

In contrast to other methods, TyCHE simultaneously reconstructs ancestral trait 
states and dates of tree nodes using trait-specific clock rates. 

## Requirements

This tutorial requires Dowser 2.4 or later.

Install BEAST 2.7.7 from [here](https://www.beast2.org/). 

You will also need to install the following BEAST packages:

- rootfreqs: [https://github.com/rbouckaert/rootfreqs](https://github.com/rbouckaert/rootfreqs)
- BEAST Classic: Can be installed via BEAST package manager (see [ here](https://www.beast2.org/tutorials/beast-package-manager/)).

Install TyCHE from [github.com/hoehnlab/tyche](https://github.com/hoehnlab/tyche).

## Setting up XML templates

BEAST models are specified and run through XML files.
We provide several BEAST XML templates in the 
[xml-templates repository](https://github.com/hoehnlab/xml-templates/). You can 
download these and modify them as needed. Additionally, you can create your own
XML templates for custom analyses.

The templates used in this tutorial are:

- `custom/StrictClock_Standard_EmpFreq.xml`: A simple strict clock model with empirical nucleotide frequencies.
- `custom/TraitLinkedExpectedOccupancy_EstTraitClockRates_EmpFreq.xml`: A trait-linked clock model using an expected occupancy method for determining the proportion of each branch in each state, estimating separate clock rates for each state, and using empirical nucleotide frequencies.

---

## Setting up data

This step proceeds as in tree building, but it is important to specify the column 
of the trait you want to analyze in the `formatClones` step. In this example we are 
using simulated data from germinal center and "other" tissue. However, this could 
be any discrete trait value such as cell types. 


```{r prepare-data, eval=FALSE} 
library(dowser)
library(dplyr)
library(ggtree)

# load example AIRR tsv data
data(ExampleAirrTyCHE)

# set up time/date trait
ExampleAirrTyche$sample_time <- as.numeric(ExampleAirrTyche$sample_time)

# trait value of interest
trait="location"

clones <- formatClones(
  ExampleAirrTyche,
  traits = c(trait, "sample_time"),
  germ   = "germline_alignment"
)

# Column shows which location the B cell was obtained from
print(table(ExampleAirrTyCHE[[trait]]))
```

```{r print-table, echo=FALSE, warning=FALSE, message=FALSE}
library(dowser)
data(ExampleAirrTyCHE)
trait="location"

print(table(ExampleAirrTyCHE[[trait]]))
```
---

## Estimating the GC clock rate

The type-linked clock models implemented in TyCHE link each trait to a separate 
molecular clock rate which can be either fixed or estimated as a parameter. The
models perform best when there is prior information about the rate of one 
or both populations. 

If you do not have an external estimate of the clock rate for each trait, you can estimate
the clock rate using a using root-to-tip regression or by fitting a strict clock 
model to pure cell populations. 

Here we estimate the clock rate of germinal center B cells using BEAST2 with a strict clock model.
```{r estimate-gc-clock-rate, eval=FALSE}
gc_cells = filter(ExampleAirrTyCHE, location=="germinal_center")
gcf = formatClones(gc_cells, traits=c("location","sample_time"),
	germ="germline_alignment")


gctrees = getTrees(gcf, build="pml", sub_model="HKY")

plotTrees(gctrees)[[1]] + geom_tippoint(aes(color=sample_time))
```
![](figure/Building-Time-Trees-gc-trees.png) 


> **Tip:** For a quick demonstration set smaller `mcmc_length` or `iterations`

```{r, eval=FALSE}
# edit to your BEAST installation path
beast <- "/Applications/BEAST 2.7.7/bin/"

# estimate clock rate of GC B cells
# Note, this will take several minutes
# if you don't care about convergence, reduce mcmc_length
gctree = getTimeTreesIterate(gcf,
	beast=beast,
	template="StrictClock_Standard_EmpFreq.xml",
	dir="temp",
	id="gc_strict",
	time="sample_time",
	mcmc_length=1e7,
	iterations=5,
	nproc=5,
	CLOCK_RATE_INIT=0.001,
	KAPPA_PRIOR_M=0.67,
	KAPPA_PRIOR_S=0.2)


gcrate_tree = mean(sapply(gctree$parameters, function(x)filter(x,item=="geneticClockRate")$mean))
print(gcrate_tree)
```
```{r, echo=FALSE}
print(0.0004308)
```

If it is not feasible to run a strict clock analysis, you can use the slope from a
root-to-tip regression. Here, we estimate the clock rate of germinal center B cells
using a root-to-tip regression.

```{r, eval=FALSE}
gcrate_slope = mean(correlationTest(gctrees, time="sample_time")$slope)
print(gcrate_slope)
```

```{r, echo=FALSE}
print(0.0003716162)
```
---


## Run getTimeTreesIterate with a TyCHE template

We can now run a trait-linked TyCHE model using the estimated GC rate. Here, we 
use the *TraitLinkedExpectedOccupancy* model, which uses an expected 
occupancy method to determine the proportion of each branch in each state. 

Features of this template:

- Allows estimation of clock rates:
  - we provide we provide values of the mean (`TRAIT_RATE_MEAN_1`, `TRAIT_RATE_MEAN_2`) 
and sigma (`TRAIT_RATE_SIGMA_1`, `TRAIT_RATE_SIGMA_2`)
for the prior distributions of each clock rate.
- Uses empirical nucleotide frequencies as the equilibrium frequencies.
  - Dowser will automatically calculate these frequencies from the input sequences.
  - Recommended for most data, especially BCRs.

`getTimeTreesIterate` is designed to run each analysis iteratively, checking for
convergence after each iteration. If the analyses converge before 
reaching the max iterations, it will stop early. It will run each analysis for `mcmc_length`
MCMC samples (here, `1e7`), and it will repeat this up to `iterations` times (here, `10`), 
so here we have a maximum of 1e8 MCMC samples. 

The convergence check is based 
on the ESS of the parameters reported in the log files. You can exclude parameters
from this ESS check using the `ignore` argument (here, we ignore `freqParameter`, as it
is a fixed value).


```{r, eval=FALSE}
mixed_trees <- getTimeTreesIterate(
  clones,
  beast    = beast,
  template = "TraitLinkedExpectedOccupancy_EstTraitClockRates_EmpFreq.xml",
  trait    = trait,
  time     = "sample_time",
  dir      = "temp",
  id       = "tyche_eo_est",
  log_every = "auto",
  nproc     = 5,
  KAPPA_PRIOR_M = 0.67,
  KAPPA_PRIOR_S = 0.2,
  TRAIT_RATE_MEAN_1 = gcrate_tree,
  TRAIT_RATE_MEAN_2 = 0.000001,
  TRAIT_RATE_SIGMA_1 = gcrate_tree * 0.01,
  TRAIT_RATE_SIGMA_2 = 0.00001,
  RATE_INDICATORS = "1 0",
  TRANSITION_RATE_ALPHA_1 = 0.1,
  TRANSITION_RATE_ALPHA_2 = 1.0,
  TRANSITION_RATE_BETA_1  = 0.1,
  TRANSITION_RATE_BETA_2  = 1.0,
  log_target   = 2000,
  mcmc_length  = 1e7,
  ignore       = c("freqParameter"),
  iterations   = 10
)
```

`getTimeTreesIterate` will run multiple BEAST2 analyses in parallel 
(here, `nproc=5`, so 5 at a time).

To capture sufficient information about the posterior distribution while keeping 
log files from becoming overly large or unwieldy, we provide the option to set 
`log_every="auto"`. This will automatically set the logging frequency based on 
the `mcmc_length` and `log_target` (here, `2000`, so we aim to have around 2000 
samples in the log file). You can also set a fixed logging frequency by providing 
an integer value.

The rate indicators (`RATE_INDICATORS`) specify which traits can transition to each
other. In a primary immune response we recommend setting this to `"1 0"`, as GC 
B cells can transition to other tissues, but not vice versa. If your data comprises
chronic infections or repeated vaccinations, you may want to allow transitions in both
directions, so you would set this to `"1 1"`.

You can also specify alpha and beta values for the prior distributions of the
transition rates between traits. We recommend setting the same prior for each transition
rate except in rare cases.

The prior distribution on kappa is used by the nucleotide substitution model, and we
recommend these values for BCR analyses.

See `?getTimeTreesIterate` and TyCHE and BEAST2 documentation for more details.

---

## Visualize the results
After the analyses have converged, you can visualize the time trees.

```{r plot-mixed-trees-result, eval=FALSE}
plotTrees(mixed_trees)[[1]] + geom_point(aes(color=location))
```
![](figure/Building-Time-Trees-mixed-trees.png)

If you want to revisit an analysis and no longer have the `mixed_trees` object 
in your R environment, you can use `readBEAST` to read in the BEAST log and tree 
files from the directory (`dir`) you specified in `getTimeTreesIterate`.



```{r read-beast-output, eval=FALSE}
mixed_trees <- readBEAST(clones, dir="temp", id="tyche_eo_est", beast=beast, trait=trait)
```

See `?readBEAST` for more details.

> **Tip:** You can find all of BEAST's output files, including the trees, logs, console logs, and TreeAnnotator outputs, in the `dir` you specified (here, "temp"). You can view these files using BEAST tools such as Tracer.

---

